/**
 * Copyright (C) 2017-2018 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version, with the additional exemption that
 * compiling, linking, and/or using OpenSSL is allowed.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * A copy of the GNU Lesser General Public License is in the file COPYING.
 */

/**
 * This registers with the local NFD to produce pre-encrypted test data for 
 * test-nac-consumer (which must be run separately).
 */

#include <cstdlib>
#include <iostream>
#include <unistd.h>
#include <ndn-cpp/security/key-chain.hpp>
#include <ndn-cpp/security/validator-null.hpp>
#include <ndn-cpp/encrypt/encryptor-v2.hpp>
#include <ndn-cpp/encrypt/access-manager-v2.hpp>
#include <cnl-cpp/namespace.hpp>

using namespace std;
using namespace ndn;
using namespace ndn::func_lib;
using namespace cnl_cpp;

static uint8_t DATA0_CONTENT[] = {
  // "This test message was decrypted"
  0x54, 0x68, 0x69, 0x73, 0x20, 0x74, 0x65, 0x73,
  0x74, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
  0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x64, 0x65,
  0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64
};

static uint8_t DATA1_CONTENT[] = {
  // " from segments."
  0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x73, 0x65,
  0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2e
};

static uint8_t AES_KEY[] = {
  0xdd, 0x60, 0x77, 0xec, 0xa9, 0x6b, 0x23, 0x1b,
  0x40, 0x6b, 0x5a, 0xf8, 0x7d, 0x3d, 0x55, 0x32
};

static uint8_t INITIAL_VECTOR[] = {
  0x73, 0x6f, 0x6d, 0x65, 0x72, 0x61, 0x6e, 0x64,
  0x6f, 0x6d, 0x76, 0x65, 0x63, 0x74, 0x6f, 0x72
};

static uint8_t DEFAULT_RSA_PUBLIC_KEY_DER[] = {
  0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
  0x00, 0xb8, 0x09, 0xa7, 0x59, 0x82, 0x84, 0xec, 0x4f, 0x06, 0xfa, 0x1c, 0xb2, 0xe1, 0x38, 0x93,
  0x53, 0xbb, 0x7d, 0xd4, 0xac, 0x88, 0x1a, 0xf8, 0x25, 0x11, 0xe4, 0xfa, 0x1d, 0x61, 0x24, 0x5b,
  0x82, 0xca, 0xcd, 0x72, 0xce, 0xdb, 0x66, 0xb5, 0x8d, 0x54, 0xbd, 0xfb, 0x23, 0xfd, 0xe8, 0x8e,
  0xaf, 0xa7, 0xb3, 0x79, 0xbe, 0x94, 0xb5, 0xb7, 0xba, 0x17, 0xb6, 0x05, 0xae, 0xce, 0x43, 0xbe,
  0x3b, 0xce, 0x6e, 0xea, 0x07, 0xdb, 0xbf, 0x0a, 0x7e, 0xeb, 0xbc, 0xc9, 0x7b, 0x62, 0x3c, 0xf5,
  0xe1, 0xce, 0xe1, 0xd9, 0x8d, 0x9c, 0xfe, 0x1f, 0xc7, 0xf8, 0xfb, 0x59, 0xc0, 0x94, 0x0b, 0x2c,
  0xd9, 0x7d, 0xbc, 0x96, 0xeb, 0xb8, 0x79, 0x22, 0x8a, 0x2e, 0xa0, 0x12, 0x1d, 0x42, 0x07, 0xb6,
  0x5d, 0xdb, 0xe1, 0xf6, 0xb1, 0x5d, 0x7b, 0x1f, 0x54, 0x52, 0x1c, 0xa3, 0x11, 0x9b, 0xf9, 0xeb,
  0xbe, 0xb3, 0x95, 0xca, 0xa5, 0x87, 0x3f, 0x31, 0x18, 0x1a, 0xc9, 0x99, 0x01, 0xec, 0xaa, 0x90,
  0xfd, 0x8a, 0x36, 0x35, 0x5e, 0x12, 0x81, 0xbe, 0x84, 0x88, 0xa1, 0x0d, 0x19, 0x2a, 0x4a, 0x66,
  0xc1, 0x59, 0x3c, 0x41, 0x83, 0x3d, 0x3d, 0xb8, 0xd4, 0xab, 0x34, 0x90, 0x06, 0x3e, 0x1a, 0x61,
  0x74, 0xbe, 0x04, 0xf5, 0x7a, 0x69, 0x1b, 0x9d, 0x56, 0xfc, 0x83, 0xb7, 0x60, 0xc1, 0x5e, 0x9d,
  0x85, 0x34, 0xfd, 0x02, 0x1a, 0xba, 0x2c, 0x09, 0x72, 0xa7, 0x4a, 0x5e, 0x18, 0xbf, 0xc0, 0x58,
  0xa7, 0x49, 0x34, 0x46, 0x61, 0x59, 0x0e, 0xe2, 0x6e, 0x9e, 0xd2, 0xdb, 0xfd, 0x72, 0x2f, 0x3c,
  0x47, 0xcc, 0x5f, 0x99, 0x62, 0xee, 0x0d, 0xf3, 0x1f, 0x30, 0x25, 0x20, 0x92, 0x15, 0x4b, 0x04,
  0xfe, 0x15, 0x19, 0x1d, 0xdc, 0x7e, 0x5c, 0x10, 0x21, 0x52, 0x21, 0x91, 0x54, 0x60, 0x8b, 0x92,
  0x41, 0x02, 0x03, 0x01, 0x00, 0x01
};

// PKCS #8 PrivateKeyInfo.
static uint8_t DEFAULT_RSA_PRIVATE_KEY_DER[] = {
  0x30, 0x82, 0x04, 0xbf, 0x02, 0x01, 0x00, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
  0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x04, 0xa9, 0x30, 0x82, 0x04, 0xa5, 0x02, 0x01,
  0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xb8, 0x09, 0xa7, 0x59, 0x82, 0x84, 0xec, 0x4f, 0x06, 0xfa,
  0x1c, 0xb2, 0xe1, 0x38, 0x93, 0x53, 0xbb, 0x7d, 0xd4, 0xac, 0x88, 0x1a, 0xf8, 0x25, 0x11, 0xe4,
  0xfa, 0x1d, 0x61, 0x24, 0x5b, 0x82, 0xca, 0xcd, 0x72, 0xce, 0xdb, 0x66, 0xb5, 0x8d, 0x54, 0xbd,
  0xfb, 0x23, 0xfd, 0xe8, 0x8e, 0xaf, 0xa7, 0xb3, 0x79, 0xbe, 0x94, 0xb5, 0xb7, 0xba, 0x17, 0xb6,
  0x05, 0xae, 0xce, 0x43, 0xbe, 0x3b, 0xce, 0x6e, 0xea, 0x07, 0xdb, 0xbf, 0x0a, 0x7e, 0xeb, 0xbc,
  0xc9, 0x7b, 0x62, 0x3c, 0xf5, 0xe1, 0xce, 0xe1, 0xd9, 0x8d, 0x9c, 0xfe, 0x1f, 0xc7, 0xf8, 0xfb,
  0x59, 0xc0, 0x94, 0x0b, 0x2c, 0xd9, 0x7d, 0xbc, 0x96, 0xeb, 0xb8, 0x79, 0x22, 0x8a, 0x2e, 0xa0,
  0x12, 0x1d, 0x42, 0x07, 0xb6, 0x5d, 0xdb, 0xe1, 0xf6, 0xb1, 0x5d, 0x7b, 0x1f, 0x54, 0x52, 0x1c,
  0xa3, 0x11, 0x9b, 0xf9, 0xeb, 0xbe, 0xb3, 0x95, 0xca, 0xa5, 0x87, 0x3f, 0x31, 0x18, 0x1a, 0xc9,
  0x99, 0x01, 0xec, 0xaa, 0x90, 0xfd, 0x8a, 0x36, 0x35, 0x5e, 0x12, 0x81, 0xbe, 0x84, 0x88, 0xa1,
  0x0d, 0x19, 0x2a, 0x4a, 0x66, 0xc1, 0x59, 0x3c, 0x41, 0x83, 0x3d, 0x3d, 0xb8, 0xd4, 0xab, 0x34,
  0x90, 0x06, 0x3e, 0x1a, 0x61, 0x74, 0xbe, 0x04, 0xf5, 0x7a, 0x69, 0x1b, 0x9d, 0x56, 0xfc, 0x83,
  0xb7, 0x60, 0xc1, 0x5e, 0x9d, 0x85, 0x34, 0xfd, 0x02, 0x1a, 0xba, 0x2c, 0x09, 0x72, 0xa7, 0x4a,
  0x5e, 0x18, 0xbf, 0xc0, 0x58, 0xa7, 0x49, 0x34, 0x46, 0x61, 0x59, 0x0e, 0xe2, 0x6e, 0x9e, 0xd2,
  0xdb, 0xfd, 0x72, 0x2f, 0x3c, 0x47, 0xcc, 0x5f, 0x99, 0x62, 0xee, 0x0d, 0xf3, 0x1f, 0x30, 0x25,
  0x20, 0x92, 0x15, 0x4b, 0x04, 0xfe, 0x15, 0x19, 0x1d, 0xdc, 0x7e, 0x5c, 0x10, 0x21, 0x52, 0x21,
  0x91, 0x54, 0x60, 0x8b, 0x92, 0x41, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01, 0x01, 0x00,
  0x8a, 0x05, 0xfb, 0x73, 0x7f, 0x16, 0xaf, 0x9f, 0xa9, 0x4c, 0xe5, 0x3f, 0x26, 0xf8, 0x66, 0x4d,
  0xd2, 0xfc, 0xd1, 0x06, 0xc0, 0x60, 0xf1, 0x9f, 0xe3, 0xa6, 0xc6, 0x0a, 0x48, 0xb3, 0x9a, 0xca,
  0x21, 0xcd, 0x29, 0x80, 0x88, 0x3d, 0xa4, 0x85, 0xa5, 0x7b, 0x82, 0x21, 0x81, 0x28, 0xeb, 0xf2,
  0x43, 0x24, 0xb0, 0x76, 0xc5, 0x52, 0xef, 0xc2, 0xea, 0x4b, 0x82, 0x41, 0x92, 0xc2, 0x6d, 0xa6,
  0xae, 0xf0, 0xb2, 0x26, 0x48, 0xa1, 0x23, 0x7f, 0x02, 0xcf, 0xa8, 0x90, 0x17, 0xa2, 0x3e, 0x8a,
  0x26, 0xbd, 0x6d, 0x8a, 0xee, 0xa6, 0x0c, 0x31, 0xce, 0xc2, 0xbb, 0x92, 0x59, 0xb5, 0x73, 0xe2,
  0x7d, 0x91, 0x75, 0xe2, 0xbd, 0x8c, 0x63, 0xe2, 0x1c, 0x8b, 0xc2, 0x6a, 0x1c, 0xfe, 0x69, 0xc0,
  0x44, 0xcb, 0x58, 0x57, 0xb7, 0x13, 0x42, 0xf0, 0xdb, 0x50, 0x4c, 0xe0, 0x45, 0x09, 0x8f, 0xca,
  0x45, 0x8a, 0x06, 0xfe, 0x98, 0xd1, 0x22, 0xf5, 0x5a, 0x9a, 0xdf, 0x89, 0x17, 0xca, 0x20, 0xcc,
  0x12, 0xa9, 0x09, 0x3d, 0xd5, 0xf7, 0xe3, 0xeb, 0x08, 0x4a, 0xc4, 0x12, 0xc0, 0xb9, 0x47, 0x6c,
  0x79, 0x50, 0x66, 0xa3, 0xf8, 0xaf, 0x2c, 0xfa, 0xb4, 0x6b, 0xec, 0x03, 0xad, 0xcb, 0xda, 0x24,
  0x0c, 0x52, 0x07, 0x87, 0x88, 0xc0, 0x21, 0xf3, 0x02, 0xe8, 0x24, 0x44, 0x0f, 0xcd, 0xa0, 0xad,
  0x2f, 0x1b, 0x79, 0xab, 0x6b, 0x49, 0x4a, 0xe6, 0x3b, 0xd0, 0xad, 0xc3, 0x48, 0xb9, 0xf7, 0xf1,
  0x34, 0x09, 0xeb, 0x7a, 0xc0, 0xd5, 0x0d, 0x39, 0xd8, 0x45, 0xce, 0x36, 0x7a, 0xd8, 0xde, 0x3c,
  0xb0, 0x21, 0x96, 0x97, 0x8a, 0xff, 0x8b, 0x23, 0x60, 0x4f, 0xf0, 0x3d, 0xd7, 0x8f, 0xf3, 0x2c,
  0xcb, 0x1d, 0x48, 0x3f, 0x86, 0xc4, 0xa9, 0x00, 0xf2, 0x23, 0x2d, 0x72, 0x4d, 0x66, 0xa5, 0x01,
  0x02, 0x81, 0x81, 0x00, 0xdc, 0x4f, 0x99, 0x44, 0x0d, 0x7f, 0x59, 0x46, 0x1e, 0x8f, 0xe7, 0x2d,
  0x8d, 0xdd, 0x54, 0xc0, 0xf7, 0xfa, 0x46, 0x0d, 0x9d, 0x35, 0x03, 0xf1, 0x7c, 0x12, 0xf3, 0x5a,
  0x9d, 0x83, 0xcf, 0xdd, 0x37, 0x21, 0x7c, 0xb7, 0xee, 0xc3, 0x39, 0xd2, 0x75, 0x8f, 0xb2, 0x2d,
  0x6f, 0xec, 0xc6, 0x03, 0x55, 0xd7, 0x00, 0x67, 0xd3, 0x9b, 0xa2, 0x68, 0x50, 0x6f, 0x9e, 0x28,
  0xa4, 0x76, 0x39, 0x2b, 0xb2, 0x65, 0xcc, 0x72, 0x82, 0x93, 0xa0, 0xcf, 0x10, 0x05, 0x6a, 0x75,
  0xca, 0x85, 0x35, 0x99, 0xb0, 0xa6, 0xc6, 0xef, 0x4c, 0x4d, 0x99, 0x7d, 0x2c, 0x38, 0x01, 0x21,
  0xb5, 0x31, 0xac, 0x80, 0x54, 0xc4, 0x18, 0x4b, 0xfd, 0xef, 0xb3, 0x30, 0x22, 0x51, 0x5a, 0xea,
  0x7d, 0x9b, 0xb2, 0x9d, 0xcb, 0xba, 0x3f, 0xc0, 0x1a, 0x6b, 0xcd, 0xb0, 0xe6, 0x2f, 0x04, 0x33,
  0xd7, 0x3a, 0x49, 0x71, 0x02, 0x81, 0x81, 0x00, 0xd5, 0xd9, 0xc9, 0x70, 0x1a, 0x13, 0xb3, 0x39,
  0x24, 0x02, 0xee, 0xb0, 0xbb, 0x84, 0x17, 0x12, 0xc6, 0xbd, 0x65, 0x73, 0xe9, 0x34, 0x5d, 0x43,
  0xff, 0xdc, 0xf8, 0x55, 0xaf, 0x2a, 0xb9, 0xe1, 0xfa, 0x71, 0x65, 0x4e, 0x50, 0x0f, 0xa4, 0x3b,
  0xe5, 0x68, 0xf2, 0x49, 0x71, 0xaf, 0x15, 0x88, 0xd7, 0xaf, 0xc4, 0x9d, 0x94, 0x84, 0x6b, 0x5b,
  0x10, 0xd5, 0xc0, 0xaa, 0x0c, 0x13, 0x62, 0x99, 0xc0, 0x8b, 0xfc, 0x90, 0x0f, 0x87, 0x40, 0x4d,
  0x58, 0x88, 0xbd, 0xe2, 0xba, 0x3e, 0x7e, 0x2d, 0xd7, 0x69, 0xa9, 0x3c, 0x09, 0x64, 0x31, 0xb6,
  0xcc, 0x4d, 0x1f, 0x23, 0xb6, 0x9e, 0x65, 0xd6, 0x81, 0xdc, 0x85, 0xcc, 0x1e, 0xf1, 0x0b, 0x84,
  0x38, 0xab, 0x93, 0x5f, 0x9f, 0x92, 0x4e, 0x93, 0x46, 0x95, 0x6b, 0x3e, 0xb6, 0xc3, 0x1b, 0xd7,
  0x69, 0xa1, 0x0a, 0x97, 0x37, 0x78, 0xed, 0xd1, 0x02, 0x81, 0x80, 0x33, 0x18, 0xc3, 0x13, 0x65,
  0x8e, 0x03, 0xc6, 0x9f, 0x90, 0x00, 0xae, 0x30, 0x19, 0x05, 0x6f, 0x3c, 0x14, 0x6f, 0xea, 0xf8,
  0x6b, 0x33, 0x5e, 0xee, 0xc7, 0xf6, 0x69, 0x2d, 0xdf, 0x44, 0x76, 0xaa, 0x32, 0xba, 0x1a, 0x6e,
  0xe6, 0x18, 0xa3, 0x17, 0x61, 0x1c, 0x92, 0x2d, 0x43, 0x5d, 0x29, 0xa8, 0xdf, 0x14, 0xd8, 0xff,
  0xdb, 0x38, 0xef, 0xb8, 0xb8, 0x2a, 0x96, 0x82, 0x8e, 0x68, 0xf4, 0x19, 0x8c, 0x42, 0xbe, 0xcc,
  0x4a, 0x31, 0x21, 0xd5, 0x35, 0x6c, 0x5b, 0xa5, 0x7c, 0xff, 0xd1, 0x85, 0x87, 0x28, 0xdc, 0x97,
  0x75, 0xe8, 0x03, 0x80, 0x1d, 0xfd, 0x25, 0x34, 0x41, 0x31, 0x21, 0x12, 0x87, 0xe8, 0x9a, 0xb7,
  0x6a, 0xc0, 0xc4, 0x89, 0x31, 0x15, 0x45, 0x0d, 0x9c, 0xee, 0xf0, 0x6a, 0x2f, 0xe8, 0x59, 0x45,
  0xc7, 0x7b, 0x0d, 0x6c, 0x55, 0xbb, 0x43, 0xca, 0xc7, 0x5a, 0x01, 0x02, 0x81, 0x81, 0x00, 0xab,
  0xf4, 0xd5, 0xcf, 0x78, 0x88, 0x82, 0xc2, 0xdd, 0xbc, 0x25, 0xe6, 0xa2, 0xc1, 0xd2, 0x33, 0xdc,
  0xef, 0x0a, 0x97, 0x2b, 0xdc, 0x59, 0x6a, 0x86, 0x61, 0x4e, 0xa6, 0xc7, 0x95, 0x99, 0xa6, 0xa6,
  0x55, 0x6c, 0x5a, 0x8e, 0x72, 0x25, 0x63, 0xac, 0x52, 0xb9, 0x10, 0x69, 0x83, 0x99, 0xd3, 0x51,
  0x6c, 0x1a, 0xb3, 0x83, 0x6a, 0xff, 0x50, 0x58, 0xb7, 0x28, 0x97, 0x13, 0xe2, 0xba, 0x94, 0x5b,
  0x89, 0xb4, 0xea, 0xba, 0x31, 0xcd, 0x78, 0xe4, 0x4a, 0x00, 0x36, 0x42, 0x00, 0x62, 0x41, 0xc6,
  0x47, 0x46, 0x37, 0xea, 0x6d, 0x50, 0xb4, 0x66, 0x8f, 0x55, 0x0c, 0xc8, 0x99, 0x91, 0xd5, 0xec,
  0xd2, 0x40, 0x1c, 0x24, 0x7d, 0x3a, 0xff, 0x74, 0xfa, 0x32, 0x24, 0xe0, 0x11, 0x2b, 0x71, 0xad,
  0x7e, 0x14, 0xa0, 0x77, 0x21, 0x68, 0x4f, 0xcc, 0xb6, 0x1b, 0xe8, 0x00, 0x49, 0x13, 0x21, 0x02,
  0x81, 0x81, 0x00, 0xb6, 0x18, 0x73, 0x59, 0x2c, 0x4f, 0x92, 0xac, 0xa2, 0x2e, 0x5f, 0xb6, 0xbe,
  0x78, 0x5d, 0x47, 0x71, 0x04, 0x92, 0xf0, 0xd7, 0xe8, 0xc5, 0x7a, 0x84, 0x6b, 0xb8, 0xb4, 0x30,
  0x1f, 0xd8, 0x0d, 0x58, 0xd0, 0x64, 0x80, 0xa7, 0x21, 0x1a, 0x48, 0x00, 0x37, 0xd6, 0x19, 0x71,
  0xbb, 0x91, 0x20, 0x9d, 0xe2, 0xc3, 0xec, 0xdb, 0x36, 0x1c, 0xca, 0x48, 0x7d, 0x03, 0x32, 0x74,
  0x1e, 0x65, 0x73, 0x02, 0x90, 0x73, 0xd8, 0x3f, 0xb5, 0x52, 0x35, 0x79, 0x1c, 0xee, 0x93, 0xa3,
  0x32, 0x8b, 0xed, 0x89, 0x98, 0xf1, 0x0c, 0xd8, 0x12, 0xf2, 0x89, 0x7f, 0x32, 0x23, 0xec, 0x67,
  0x66, 0x52, 0x83, 0x89, 0x99, 0x5e, 0x42, 0x2b, 0x42, 0x4b, 0x84, 0x50, 0x1b, 0x3e, 0x47, 0x6d,
  0x74, 0xfb, 0xd1, 0xa6, 0x10, 0x20, 0x6c, 0x6e, 0xbe, 0x44, 0x3f, 0xb9, 0xfe, 0xbc, 0x8d, 0xda,
  0xcb, 0xea, 0x8f
};

// This matches MEMBER_PRIVATE_KEY in test-nac-consumer.
static uint8_t MEMBER_PUBLIC_KEY[] = {
  0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
  0x00, 0xd2, 0x1c, 0x8d, 0x80, 0x78, 0xcc, 0x92, 0xb7, 0x6e, 0xfd, 0x28, 0xdc, 0xb4, 0xa7, 0x81,
  0x98, 0xa4, 0x31, 0x02, 0x01, 0x49, 0x58, 0xc4, 0x27, 0x0e, 0x7d, 0xe2, 0xa4, 0xca, 0xd0, 0x98,
  0x2a, 0xb6, 0x0d, 0xff, 0x14, 0x36, 0xbf, 0x3e, 0xb9, 0xa1, 0x9c, 0x8b, 0x5b, 0xd8, 0x47, 0x12,
  0x3e, 0xfe, 0x66, 0xb7, 0x73, 0x5f, 0x54, 0xc3, 0xe7, 0x3d, 0x03, 0xe5, 0xab, 0x56, 0x3f, 0xbf,
  0x25, 0xa6, 0xe6, 0x9b, 0x74, 0x83, 0xab, 0x30, 0xba, 0xab, 0xff, 0x20, 0xb6, 0xb7, 0xee, 0x4f,
  0x77, 0x9e, 0xc3, 0xfe, 0xb8, 0xef, 0x2a, 0x15, 0x2d, 0x24, 0x68, 0x49, 0x58, 0xe5, 0x3b, 0x50,
  0xbb, 0x4e, 0x72, 0x92, 0xbb, 0xfc, 0x98, 0x62, 0xe2, 0x58, 0xc7, 0x2d, 0xf6, 0x46, 0xb1, 0x07,
  0xbc, 0x68, 0x68, 0x29, 0xf6, 0x31, 0x79, 0x9c, 0xc6, 0x00, 0xc3, 0x5d, 0xce, 0x4a, 0xcf, 0x26,
  0xfb, 0xf6, 0x9b, 0x3b, 0x7a, 0xa6, 0xfa, 0x89, 0xaa, 0xc9, 0xc0, 0xf2, 0x08, 0x46, 0xcd, 0x45,
  0xf6, 0x38, 0xab, 0x90, 0x1e, 0xd6, 0xa1, 0x6e, 0x48, 0xa0, 0xe5, 0x5f, 0x59, 0x35, 0x2c, 0x0d,
  0xe9, 0x3d, 0x3c, 0x9f, 0x8d, 0x28, 0xec, 0x24, 0xbc, 0x63, 0x43, 0x75, 0x00, 0x07, 0xf3, 0x45,
  0xf4, 0x93, 0x35, 0x42, 0x4c, 0x90, 0xea, 0x4f, 0x0a, 0x44, 0x4e, 0xda, 0x7a, 0xd5, 0xad, 0x8d,
  0x12, 0x21, 0xc5, 0x63, 0x74, 0xc2, 0x80, 0x2f, 0xe6, 0x27, 0x54, 0xc3, 0xf8, 0xd6, 0x24, 0x7e,
  0x44, 0x95, 0xc8, 0x3e, 0x1f, 0x43, 0x8e, 0x56, 0x67, 0xbd, 0xb5, 0x9d, 0xfd, 0x9a, 0xad, 0x5a,
  0x0a, 0x88, 0xc3, 0x8c, 0xb9, 0xaf, 0x29, 0x71, 0x51, 0x70, 0x87, 0x6f, 0xee, 0x0e, 0xd0, 0x27,
  0x3b, 0x95, 0xeb, 0x66, 0xe1, 0x4a, 0x4b, 0x67, 0xab, 0x90, 0x43, 0xd5, 0x51, 0xad, 0x57, 0x08,
  0xd5, 0x02, 0x03, 0x01, 0x00, 0x01
};

static void
onError(EncryptError::ErrorCode errorCode, const string& message)
{
  cout << "onErrpr: " << message << endl;
}

/**
 * Create the encrypted CK Data and KDK, and add to the Namespace object.
 * For the meaning of "CK data", etc. see:
 * https://github.com/named-data/name-based-access-control/blob/new/docs/spec.rst
 * @return The EncryptorV2 for encrypting the content.
 */
static ptr_lib::shared_ptr<EncryptorV2>
prepareData
  (const Name& ckPrefix, KeyChain* keyChain, Face* face, Face* accessManagerFace,
   Validator* validator)
{
  // Imitate test-encryptor-v2 and test-access-manager-v2 from the unit tests.
  ptr_lib::shared_ptr<PibIdentity> accessIdentity = keyChain->createIdentityV2
    (Name("/access/policy/identity"), RsaKeyParams());
  // This matches memberKeyName in test-nac-consumer.
  Name memberKeyName("/first/user/KEY/%0C%87%EB%E6U%27B%D6");

  // The member certificate only needs to have a name and public key.
  CertificateV2 memberCertificate;
  memberCertificate.setName(Name(memberKeyName).append("self").append("1"));
  memberCertificate.setContent(Blob(MEMBER_PUBLIC_KEY, sizeof(MEMBER_PUBLIC_KEY)));

  Name dataset("/dataset");
  AccessManagerV2 accessManager(accessIdentity, dataset, keyChain, accessManagerFace);
  // The face now has callbacks to the AccessManagerV2 and will keep it alive.
  accessManager.addMember(memberCertificate);

  // TODO: Sign with better than SHA256?
  return ptr_lib::make_shared<EncryptorV2>
    (Name(accessIdentity->getName()).append("NAC").append(dataset),
     ckPrefix, SigningInfo(SigningInfo::SIGNER_TYPE_SHA256),
     &onError, validator, keyChain, face);
}

class TestProducer {
public:
  /**
   * Create a TestProducer with an onObjectNeeded callback to produce the
   * encrypted segments.
   */
  TestProducer
    (const Name& contentPrefix, EncryptorV2* encryptor, KeyChain* keyChain)
  : contentPrefix_(contentPrefix), encryptor_(encryptor), keyChain_(keyChain)
  {
  }

  bool
  onObjectNeeded
     (Namespace& nameSpace, Namespace& neededNamespace, uint64_t callbackId)
  {
    if (!(neededNamespace.getName().size() == contentPrefix_.size() + 1 &&
          contentPrefix_.isPrefixOf(neededNamespace.getName()) &&
          neededNamespace.getName()[-1].isSegment()))
        // Not a content segment, ignore.
        return false;

    // Get the segment number.
    uint64_t segment = neededNamespace.getName()[-1].toSegment();
    if (!(segment >= 0 && segment <= 1))
      // An invalid segment was requested.
      return false;

    // Make the Data packet for the segment. Imitate createEncryptedContent.
    ptr_lib::shared_ptr<Data> data = ptr_lib::make_shared<Data>
      (Name(contentPrefix_).appendSegment(segment));
    string segmentContent;
    if (segment == 0)
      segmentContent = "This test message was decrypted";
    else
      segmentContent = " from segments.";
    data->setContent
      (encryptor_->encrypt
       (Blob((const uint8_t*)segmentContent.c_str(), segmentContent.size()))->wireEncodeV2());
    data->getMetaInfo().setFinalBlockId(Name().appendSegment(1)[0]);
    keyChain_->sign(*data);

    // Now call setData which will answer the pending incoming Interest.
    // Note that the encrypted name has extra child components for the C-KEY.
    cout << "Produced data " << data->getName() << endl;
    neededNamespace[data->getName()].setData(data);
    return true;
  }

  void
  onRegisterFailed(const ptr_lib::shared_ptr<const Name>& prefix)
  {
    cout << "Register failed for prefix " << prefix->toUri() << endl;
  }

private:
  Name contentPrefix_;
  EncryptorV2* encryptor_;
  KeyChain* keyChain_;
};

int main(int argc, char** argv)
{
  try {
    // The default Face will connect using a Unix socket, or to "localhost".
    Face face;

    // Create an in-memory key chain with default keys.
    KeyChain keyChain("pib-memory:", "tpm-memory:");
    keyChain.importSafeBag(SafeBag
      (Name("/testname/KEY/123"),
       Blob(DEFAULT_RSA_PRIVATE_KEY_DER, sizeof(DEFAULT_RSA_PRIVATE_KEY_DER)),
       Blob(DEFAULT_RSA_PUBLIC_KEY_DER, sizeof(DEFAULT_RSA_PUBLIC_KEY_DER))));
    face.setCommandSigningInfo(keyChain, keyChain.getDefaultCertificateName());

    Name contentPrefix("/testname/content");
    Namespace contentNamespace(contentPrefix, &keyChain);

    // We know the content has two segments.
    MetaInfo metaInfo;
    metaInfo.setFinalBlockId(Name().appendSegment(1)[0]);
    contentNamespace.setNewDataMetaInfo(metaInfo);

    Name ckPrefix("/some/ck/prefix");
    ValidatorNull validator;
    // Use a different Face so it can communicate with the primary Face.
    Face accessManagerFace;
    accessManagerFace.setCommandSigningInfo(keyChain, keyChain.getDefaultCertificateName());
    ptr_lib::shared_ptr<EncryptorV2> encryptor = prepareData
      (ckPrefix, &keyChain, &face, &accessManagerFace, &validator);

    // Make the callback to produce a Data packet for a content segment.
    TestProducer testProducer(contentPrefix, encryptor.get(), &keyChain);
    contentNamespace.addOnObjectNeeded
      (bind(&TestProducer::onObjectNeeded, &testProducer, _1, _2, _3));

    cout << "Register prefix " << contentNamespace.getName().toUri() << endl;
    // Set the face and register to receive Interests.
    contentNamespace.setFace
      (&face, bind(&TestProducer::onRegisterFailed, &testProducer, _1));

    while (true) {
      face.processEvents();
      accessManagerFace.processEvents();
      // We need to sleep for a few milliseconds so we don't use 100% of the CPU.
      usleep(10000);
    }
  } catch (std::exception& e) {
    cout << "exception: " << e.what() << endl;
  }
  return 0;
}
